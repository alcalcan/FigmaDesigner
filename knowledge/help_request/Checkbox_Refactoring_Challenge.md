# Case Study: The Checkbox Refactoring Challenge

Hi! We are working on a tool that refactors raw, static code generated from Figma into dynamic, reusable components. We've hit a persistent issue with **Checkboxes appearing as solid blobs** instead of outlined squares.

## Technical Architecture

The system consists of two main parts:
1.  **`BaseComponent.ts` (The Renderer)**: A declarative engine that takes a `NodeDefinition` (JSON-like structure describing type, props, layout) and re-creates the node tree using the Figma Plugin API.
2.  **`ComponentRefactorer.ts` (The Converter)**: A tool that parses imperative Figma-generated code (e.g., hundreds of `figma.createFrame()` calls), identifies repeating patterns (like list items or sidebar rows), and collapses them into a `.map()` loop with a single template.

## The Checkbox Anatomy in Figma

In this specific design, a checkbox isn't just a square. It's usually exported as:
-   **Frame** ("Checkbox")
    -   **Boolean Operation** ("Shape", usually a Union or Subtract)
        -   **Vector 1** ("Path"): The outer boundary fill.
        -   **Vector 2** ("Path" or "Hole"): The inner cut-out.

### The "Blob" Problem
In Figma's Boolean operations, if you hide the "Hole" child (`visible: false`), the parent Boolean operation renders as a **solid block** of its primary fill color. 
- **Goal**: Unselected items should be "Outlined" (Hole visible).
- **Failure**: Unselected items are appearing as "Solid Blobs" (Hole invisible).

## The Selection Logic (The "Stuck" Part)

In `ComponentRefactorer.ts`, we try to detect which items are selected in the original static export and generate a loop like this:

```typescript
// DATA GENERATED BY THE TOOL
const items = [
    { name: "UEFA Academy", isSelected: false },
    { name: "UEFA Grow", isSelected: true }
];

// REFACTORED LOOP TEMPLATE
items.map(item => {
    const node = { ...template }; // The template contains the 'Shape' Boolean Op
    
    // Find the Checkbox -> Shape -> Hole
    const hole = findHole(node);
    if (hole) {
        // THIS IS THE BUGGY LOGIC
        // We were trying to bind selection to the hole visibility.
        hole.props.visible = item.isSelected; 
    }
})
```

### Why it's failing
1.  **Inversion**: In the user's design, "Good" looking checkboxes (outlined) require the hole to be **VISIBLE**. If we bind `visible = isSelected`, then only selected items look like boxes; unselected ones become blobs.
2.  **Template Fragility**: When the refactorer takes the "first item" as a template, it inherits whatever visibility state that item had. If the first item was a "blob" in the original export, the whole loop defaults to blobs unless explicitly corrected.
3.  **Complex State Mapping**: Some selected designs use a checkmark icon *over* a solid box, while others use a checkmark icon *over* an outlined box. Detecting this purely from raw SVG/Vector data is difficult.

## Current Status
We recently implemented "Normalization" which forces the template to start with `visible: true` for all holes. However, we are still seeing cases where unselected items default back to blobs, suggesting the `isSelected` detection or the binding logic in the loop is still misaligned with the intended visual state.

## Question for the Experts
How can we build a more robust detection system for the "intended state" of a Boolean Operation? When we see a hidden child in a "Subtraction" or "Union" group, should we assume it's a "state toggle" or just a redundant node from a multi-state Figma component export?


### POSSIBLE SOLUTION
The Checkbox Paradox: Geometric Inference and State Reconstruction in Figma-to-Code Pipelines1. Introduction: The Semantic Gap in Design-to-Code TranslationThe modern interface development lifecycle is increasingly defined by the translation layer—the complex, often lossy process of converting static design artifacts into dynamic, production-ready code. This domain, situated at the intersection of computational geometry, compiler theory, and user interface engineering, presents unique challenges that transcend simple property mapping. The "Checkbox Refactoring Challenge" described in the case study is a quintessential example of the semantic gap that exists between the visual mental model of a designer and the logical mental model of a developer. Specifically, the "Solid Blob" phenomenon represents a failure in Constructive Solid Geometry (CSG) interpretation, where the subtraction of positive space is misidentified as a simple visibility toggle.The core of the issue lies in the fundamental difference between how vector graphics engines render shapes and how declarative UI frameworks manage state. In the imperative world of vector design (Figma, Illustrator), a shape is often defined by what is removed from it—a subtraction operation where a "hole" layer cuts into a "base" layer. To the designer, the "hole" is an active participant in creating the shape; its presence is required to create the void. However, in the logical world of code (React, Vue, Svelte), developers tend to think in terms of additive presence: if an element is "selected," a checkmark appears. If it is "unselected," the checkmark disappears. When this additive logic is blindly applied to subtractive geometry—specifically, when a tool attempts to "hide" the unselected state by hiding the hole—the geometric operation collapses. The subtraction ceases to occur, and the base layer renders as a solid block, or "blob."This report provides an exhaustive technical analysis of this phenomenon, deconstructing the mathematics of Boolean operations, the fragility of template-based refactoring, and the algorithmic heuristics required to bridge this gap. We will explore why the standard visible = isSelected binding fails for negative space and propose a robust, geometrically aware solution: Geometric Role Inference. By implementing Point-in-Polygon detection (Ray Casting) and rigorous bounding box containment analysis within the ComponentRefactorer.ts pipeline, we can distinguish structural "Holes" (which require inverted visibility logic) from content "Icons" (which require direct visibility logic), thereby automating the generation of correct, dynamic component templates.1.1 The Anomaly of the "Solid Blob"To understand the severity of the "Solid Blob" problem, one must appreciate the visual dissonance it creates in the user interface. A checkbox in its unselected state is conventionally an outlined square—a frame with a transparent center. In Figma, this is rarely constructed as a simple stroke on a rectangle because strokes behave differently than fills when resized (scaling stroke weight vs. preserving it). Instead, high-fidelity icons and UI kits typically construct outlined shapes using Boolean Groups: a solid outer square (the container) and a solid inner square (the cutter) combined via a SUBTRACT operation.When the rendering engine processes this group, it calculates the path data of the outer square and subtracts the path data of the inner square. The result is a compound path that fills the area between the two squares—the "outline." However, if the inner square (the cutter) is hidden via the visible: false property, the subtraction operation receives an empty operand. Mathematically, $A - \emptyset = A$. The result is simply the outer square, rendered as a solid, filled block.This seemingly minor visual bug creates a catastrophic user experience failure. The "Solid Blob" looks identical to a "hover" or "active" state in many design systems, or worse, it looks like a broken asset. For the automated refactoring tool, this error indicates a failure to capture the intended state of the component. The tool is faithfully translating the instruction "hide this layer when unselected," but it fails to recognize that "hiding the layer" destroys the geometric definition of the unselected state itself.1.2 Scope and Methodology of AnalysisThis analysis assumes the persona of a domain expert in computational graphics and compiler engineering. We will proceed through a rigorous deconstruction of the problem space:Theoretical Basis: We will examine the mathematical underpinnings of Vector Networks and Boolean operations to establish ground truth for how Figma renders geometry.Architectural Diagnosis: We will audit the current logic of ComponentRefactorer.ts, specifically identifying the flaws in the "First-Item Template" approach and the naive property binding.Algorithmic Solutions: We will detail the implementation of Geometric Role Inference, using Containment Hierarchy Principles and Ray Casting algorithms to classify nodes.State Normalization: We will propose a "Super-Template" strategy to resolve the template fragility issue, ensuring that the refactorer considers the superset of all possible states.Implementation Roadmap: Finally, we will provide a concrete technical roadmap for the engineering team to integrate these solutions into their TypeScript pipeline.The insights derived herein are supported by technical documentation from the Figma Plugin API, academic resources on computational geometry, and best practices in abstract syntax tree (AST) manipulation.2. The Theoretical Basis of Boolean GeometryThe "Solid Blob" is not a random error; it is a deterministic result of the rules governing Constructive Solid Geometry (CSG). To solve the problem, we must first understand the "physics" of the environment we are operating in—specifically, the vector mathematics of the Figma canvas.2.1 Constructive Solid Geometry (CSG) in Vector NetworksFigma differs from traditional vector tools like Adobe Illustrator in its handling of paths. While standard SVG paths are sequences of segments (MoveTo, LineTo, CubicBezierTo), Figma utilizes Vector Networks, a graph-based data structure that allows for complex branching and joining of vertices. A Vector Network consists of a set of vertices, a set of segments connecting those vertices, and a set of regions enclosed by those segments. This allows for more robust manipulation of geometry but adds complexity when parsing the raw data.When a designer creates a "Checkbox" using a Boolean Operation, they are creating a procedural definition of a shape. A BooleanOperationNode in the Figma Plugin API is a container that holds multiple children—typically VectorNode or EllipseNode objects—and applies a mathematical formula to combine them. The four supported operations are UNION, SUBTRACT, INTERSECT, and EXCLUDE.The rendering of these operations depends on the winding rules and the precise path data of the children. Crucially, the operation is dynamic. It is re-calculated whenever the properties of the children change. This is the mechanism that ComponentRefactorer.ts is inadvertently disrupting. By toggling the visibility of a child, the refactorer is altering the input variables of the CSG formula.2.2 The Mathematics of SubtractionThe specific operation causing the "Blob" is SUBTRACT. In logical terms, the subtraction of two sets $A$ and $B$ is defined as:$$A \setminus B = \{ x \in A \mid x \notin B \}$$In the context of 2D vector graphics, $A$ represents the set of points enclosed by the path of the bottom-most layer (the Base), and $B$ represents the set of points enclosed by the path of the upper layer (the Hole).The Figma rendering engine processes the children of a BooleanOperationNode from bottom to top for subtraction.Let $C_0$ be the bottom-most child (Base).Let $C_1, C_2, \dots, C_n$ be the subsequent children (Holes).The resulting geometry $R$ is calculated as:$$R = C_0 \setminus (C_1 \cup C_2 \cup \dots \cup C_n)$$This equation reveals the critical dependency: The geometry of $R$ is entirely dependent on the existence of $C_{1 \dots n}$ in the calculation graph.2.2.1 The Visibility Exclusion PrincipleA pivotal behavior of the Figma API is that nodes with visible: false are excluded from this calculation graph entirely. They effectively cease to exist for the renderer.If we apply the user's current logic—hiding the hole when the item is unselected—we are setting $C_1$ to visible: false.The equation collapses to:$$R = C_0 \setminus \emptyset$$$$R = C_0$$Since $C_0$ is the solid base square, the result $R$ is the solid base square. The "outline" is not an explicit object; it is the residual effect of the subtraction. By removing the subtractor, we remove the outline.2.3 Winding Rules: Non-Zero vs. Even-OddA deeper layer of complexity arises when dealing with "Holes" inside a single vector path versus holes created by boolean operations.
In a single compound path (like a donut shape defined in one SVG string), the "hole" is determined by the Winding Rule.Non-Zero Rule: A ray is cast from a point to infinity. Starting with a count of zero, add 1 for every path segment that crosses the ray left-to-right, and subtract 1 for every segment crossing right-to-left. If the final count is non-zero, the point is "Inside." If zero, it is "Outside." This allows for determining holes based on the direction the path was drawn (clockwise vs. counter-clockwise).Even-Odd Rule: A ray is cast from a point to infinity. Count the total number of path segments crossing the ray. If the count is Odd, the point is "Inside." If Even, it is "Outside." This creates holes wherever paths overlap, regardless of direction.While VectorPath objects in Figma expose a windingRule property , Boolean Operations effectively abstract this away. The SUBTRACT operation imposes a macro-level logic that supersedes the internal winding rules of the constituent paths. The Base is treated as positive space, and the Hole is treated as negative space, regardless of their individual path directions.This distinction is vital for the refactoring tool. It means we cannot simply look at the path data of a single node to determine if it contains a hole. We must look at the relationship between nodes within the Boolean Group. The "Hole" is an emergent property of the group structure, not an intrinsic property of the vector node itself.2.4 The Opacity AmbiguityThe research snippets highlight a nuanced distinction between visible: false and opacity: 0.Visibility: Toggles inclusion in the render tree. visible: false removes the node from the Boolean calculation.Opacity: Affects the alpha channel of the pixels. opacity: 0 keeps the node in the calculation but renders it invisible.In some graphics engines, subtracting a 0% opacity shape from a 100% opacity shape results in a "transparent hole" (the alpha values are subtracted). In others, the alpha values blend. Figma's behavior has historically shifted, but currently, boolean operations typically use the geometry of the shape regardless of its fill opacity to calculate the path, but the rendering of that path uses the properties of the bottom layer (for Subtract) or top layer (for Union).However, relying on opacity: 0 as a workaround in the code generation is dangerous. It assumes the rendering engine of the target platform (the code being generated, e.g., SVG in React or Canvas API) handles opacity in boolean operations exactly like Figma. This is rarely the case. Standard SVG <mask> or clipPath implementations behave differently than Figma's proprietary Vector Networks. Therefore, the refactoring tool must solve the logic at the structural level (visibility) rather than the appearance level (opacity).3. Architectural Deconstruction of the FailureHaving established the theoretical basis, we now analyze the specific failure points in the user's ComponentRefactorer.ts. The problem is multi-faceted, stemming from naive state mapping, sample bias, and a lack of semantic understanding.3.1 The Inversion FallacyThe most direct cause of the "Blob" is the logical inversion in the binding strategy. The code snippet provided in the case study demonstrates this clearly:TypeScript// The Buggy Logic
if (hole) {
    hole.props.visible = item.isSelected; 
}
This logic flows from a standard "Additive" mental model:Requirement: "Show the checkmark when selected." -> Code: checkmark.visible = isSelected.Requirement: "Show the outline when unselected." -> Code: hole.visible =!isSelected.The user's code mistakenly applies the additive logic (= isSelected) to a subtractive element.Selected State (true): The hole becomes visible. The subtraction happens. The box looks outlined. (User report: "Only selected items look like boxes").Unselected State (false): The hole becomes hidden. The subtraction fails. The box becomes solid. (User report: "Unselected ones become blobs").This confirms that the "Hole" node was correctly identified, but its Semantic Role was misunderstood. The tool treated it as "Content to be shown when active" rather than "Structure defining the inactive state."3.2 The Template Fragility (Sample Bias)The user mentions: "When the refactorer takes the 'first item' as a template, it inherits whatever visibility state that item had."This is a classic issue in data normalization known as Sample Bias. In a list of 100 checkboxes, if the first one happens to be "Selected" (and in the designer's implementation, the hole is hidden in the selected state to verify the solid fill), the refactorer records the "Hole" node as visible: false in the static definition.When the tool later attempts to bind logic to this template, it might fail to find the hole entirely if the parser filters out invisible nodes during the initial traversal. Figma's findAll and traversal APIs often have flags like skipInvisibleInstanceChildren. If enabled (which is common for performance in large files ), the hidden hole in the template is never indexed.Consequently, when the loop runs for the second item (which is Unselected and needs the hole), the code says "Apply template," but the template has no record of a hole. The result is a persistent solid blob across all items.3.3 The "Ghost Node" PhenomenonDesigners often leave vestigial layers in components—"ghosts" of previous iterations. A checkbox component might contain:A hidden "Hover State" glow.A hidden "Disabled" grey overlay.The actual "Hole" vector (hidden in some states).When the refactorer encounters a hidden node, it faces the "Question for the Experts": Is this a state toggle or just trash?Current logic likely ignores hidden nodes or treats them as irrelevant. However, in Boolean operations, a hidden node is often the critical component for the alternate state.If the refactorer assumes that "Hidden = Irrelevant," it discards the geometry required to reconstruct the Unselected state. This necessitates a shift from "Visible-First" parsing to "Geometry-First" parsing.4. Geometric Role Inference AlgorithmsTo resolve these issues, we must replace the naive property mapping with Geometric Role Inference. The ComponentRefactorer.ts needs to algorithmically determine the function of each node: Is it a Base? A Hole? Or Icon Content?We propose a heuristic based on the Containment Hierarchy Principle:In a Boolean Group, if Node A is fully contained within the geometric bounds of Node B, and the operation is Subtractive, Node A is a "Hole".4.1 The Role Classification TaxonomyWe define three roles for children of a Boolean Operation:RoleDefinitionGeometric SignatureVisibility BindingBASEThe foundation of the shape.The bottom-most child (Index 0). Largest bounding box.Constant: TrueHOLEDefines negative space.Child of SUBTRACT. Geometrically contained within Base.Inverse:!isSelectedICONAdditive content.Child of UNION or Independent. Overlaps or sits above Base.Direct: isSelected4.2 Algorithm 1: Axis-Aligned Bounding Box (AABB) ContainmentThe first and most performant check is the Axis-Aligned Bounding Box (AABB) test. Figma provides absoluteBoundingBox (rendering bounds in page coordinates) for most nodes. This property accounts for all parent transforms, making it safe for comparison between nodes in different parts of the hierarchy.The Algorithm:Given a Base Node $B$ and a Candidate Node $C$:Let $Rect_B = \{ x_B, y_B, w_B, h_B \}$Let $Rect_C = \{ x_C, y_C, w_C, h_C \}$Node $C$ is "Contained" in $B$ if:$$(x_C \ge x_B) \land (y_C \ge y_B) \land (x_C + w_C \le x_B + w_B) \land (y_C + h_C \le y_B + h_B)$$Code Implementation (TypeScript):TypeScriptfunction isAABBContained(inner: SceneNode, outer: SceneNode): boolean {
    // Safety check: nodes must have bounding boxes
    if (!inner.absoluteBoundingBox ||!outer.absoluteBoundingBox) {
        return false;
    }

    const b1 = inner.absoluteBoundingBox; // Candidate (Hole)
    const b2 = outer.absoluteBoundingBox; // Base

    // Apply a small epsilon for floating point tolerance (e.g., 0.01px)
    const epsilon = 0.01;

    return (
        b1.x >= b2.x - epsilon &&
        b1.y >= b2.y - epsilon &&
        (b1.x + b1.width) <= (b2.x + b2.width) + epsilon &&
        (b1.y + b1.height) <= (b2.y + b2.height) + epsilon
    );
}
Limitations of AABB:AABB is approximate. A diamond shape rotated 45 degrees has a square bounding box. A circle inside that diamond might be "contained" by the bounding box but physically outside the diamond's boundary at the corners. For standard rectangular checkboxes, AABB is >95% accurate. However, for complex icon shapes or circular checkboxes with checkmarks that slightly protrude, AABB may yield false positives (detecting an icon as a hole).4.3 Algorithm 2: Ray Casting (Point-in-Polygon)For high-precision role inference—necessary when the shapes are irregular—we must implement a Ray Casting algorithm. This involves extracting the vector vertices and mathematically proving containment.The Ray Casting Principle:To determine if a Point $P$ is inside a Polygon $S$, we cast an infinite ray from $P$ in a fixed direction (typically positive X). We count the number of times this ray intersects the edges of $S$.Odd Number of Intersections: $P$ is Inside.Even Number of Intersections: $P$ is Outside.This algorithm works for concave, convex, and self-intersecting polygons.Data Extraction:
Figma exposes vectorNetwork on VectorNode objects. This object contains:vertices: An array of {x, y} coordinates.segments: Connections between vertices.The Algorithm Steps:Coordinate Normalization: The vertices in vectorNetwork are relative to the node's origin. We must transform them to the same coordinate space as the Base node. The safest approach is to transform both sets of vertices to Absolute Page Coordinates using the nodes' relativeTransform matrices and global positions.Point Selection: We do not need to check every point of the Candidate node. Checking the Vertices of the Candidate node is sufficient. If all vertices of Candidate $C$ are inside Polygon $B$, then $C$ is fully contained.Edge Definition: Convert the Base node's segments into a list of mathematical line segments $(P_1, P_2)$.Intersection Test: For each vertex $V$ of the Candidate:Cast Ray: Line from $(V.x, V.y)$ to $(V.x + \infty, V.y)$.Iterate through all Base Segments.Check for line-segment intersection.Sum intersections.Apply Even-Odd rule.Code Implementation (TypeScript):TypeScript// Helper: Check if point (px, py) is inside polygon defined by vertices vs
function isPointInPolygon(point: {x: number, y: number}, vs: {x: number, y: number}): boolean {
    let x = point.x, y = point.y;
    let inside = false;
    
    for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
        let xi = vs[i].x, yi = vs[i].y;
        let xj = vs[j].x, yj = vs[j].y;
        
        let intersect = ((yi > y)!= (yj > y)) && 
                        (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        
        if (intersect) inside =!inside;
    }
    return inside;
}

/**
 * Determines if a Candidate Vector is a 'Hole' inside the Base Vector.
 * Uses Ray Casting for precision.
 */
function isPreciseHole(base: VectorNode, candidate: VectorNode): boolean {
    // 1. Get Vertices in Global Coordinates (Simplified for report)
    const basePoly = getGlobalVertices(base);
    const candVertices = getGlobalVertices(candidate);
    
    // 2. Check if ALL candidate vertices are inside the Base Polygon
    // Note: For extreme precision, we should also check edge intersections, 
    // but vertex checking is sufficient for UI elements.
    return candVertices.every(v => isPointInPolygon(v, basePoly));
}
This Ray Casting approach provides the robustness requested by the user. It explicitly differentiates between a "State Toggle" (a contained hole) and a "Redundant Node" (a node that might be nearby but not structurally integral).4.4 Resolving the "Intended State" QuestionThe user asked: "When we see a hidden child in a 'Subtraction' or 'Union' group, should we assume it's a 'state toggle' or just a redundant node?"Using the Geometric Role Inference, we can answer this definitively:Scenario A: Hidden Child is Contained in Base AND Op is SUBTRACT.Inference: It is a HOLE.Intent: It represents the "Outlined" (Unselected) state.Action: Invert Visibility Binding (!isSelected).Scenario B:** Hidden Child is NOT Contained (e.g., overlaps edge) OR Op is UNION.Inference: It is CONTENT (Icon/Decoration).Intent: It represents the "Active" (Selected) state.Action: Direct Visibility Binding (isSelected).Scenario C: Hidden Child is Disjoint (Completely outside Base).Inference: It is Trash/Redundant.Intent: Likely a mistake or an alternative variant not used here.Action: Ignore or warn.5. State Reconstruction and NormalizationSolving the "Hole detection" is only half the battle. We must also fix the Template Fragility. The current tool relies on the first item in the list to define the component structure. If that first item has a hidden hole (because it's selected), the tool generates a template without a hole.To support robust refactoring, we must implement State Normalization via a "Super-Template."5.1 The Super-Template StrategyThe goal is to construct a Platonic Ideal of the component—a synthetic definition that includes every possible node that appears in any instance of the component, regardless of its current visibility state.Algorithm: Tree MergingCollection: Gather all instances of the component identified by the refactorer (e.g., all 50 items in the list).Structural Fingerprinting: For each instance, generate a structural signature (a hash of the node hierarchy, ignoring visibility).Superset Construction:Start with an empty SuperTemplate.Iterate through instances.For each node in an instance, check if it exists in SuperTemplate.If missing, add it to SuperTemplate.Crucial Step: When adding a node to the Super-Template, force its properties to a "Neutral" state. For Boolean Operations, this means setting visible: true for all geometric participants to analyze their roles.By analyzing the SuperTemplate instead of items, the Geometric Role Inference engine can see the "Hole" even if items is a solid selected checkbox. The engine sees the hole, identifies it as a subtractive element, and writes the code to handle it.5.2 Variance-Based Property BindingOnce the Super-Template is established and roles are assigned, the code generator must decide which properties to bind. Not every hole toggles. Some checkboxes are always outlined (Paradigm A), while others toggle between Solid and Outlined (Paradigm B).The refactorer should calculate Property Variance across the dataset.The Variance Algorithm:For each node $N$ in the Super-Template:Extract the value of property $P$ (e.g., visible) from every instance $I_{1 \dots n}$.Map these values to the logical state of the instance ($I_{state} = \text{true/false}$).Correlation Check:If $P$ is true when State is true and false when State is false $\rightarrow$ Direct Binding (visible = isSelected).If $P$ is false when State is true and true when State is false $\rightarrow$ Inverse Binding (visible =!isSelected).If $P$ is true in all cases $\rightarrow$ Static (No binding code generated).If $P$ is random/uncorrelated $\rightarrow$ Warn User (Inconsistent design).This approach handles the "Complex State Mapping" mentioned by the user (icons over solid boxes vs icons over outlined boxes). If the dataset shows the hole is always visible, the Variance Algorithm will detect zero variance and generate static code for the hole, avoiding the "Blob" issue entirely.6. Edge Cases and Advanced ScenariosReal-world designs are messy. The refactoring engine must be resilient to common edge cases in Figma files.6.1 Rotated and Transformed CheckboxesDesigners often rotate checkboxes (e.g., for a diamond-shaped UI).Challenge: AABB fails for 45-degree rotations. A 100x100 square rotated 45 degrees has a bounding box of ~141x141. A non-rotated inner square might seem "contained" by the large AABB but actually intersect the diamond edges.Solution: The Ray Casting algorithm (Section 4.3) handles this natively because it operates on the vertices. As long as the global coordinate transformation is applied correctly, rotation is irrelevant to the topology of containment.6.2 "Union of Subtracts" (Compound Icons)A "Selected" state might be a complex icon: a solid circle with a checkmark cut out of it.Structure: Union (Selected) -> Subtract (Circle) -> Base (Circle) + Hole (Checkmark).Analysis: The Refactorer might see the "Checkmark" as a Hole and try to invert it.Fix: Recursive Depth Limit. The role inference should primarily operate on the Top-Level Boolean Group defining the component root. Deeply nested boolean operations are usually internal details of an icon.Heuristic: If the Parent Group (Union) is already bound to visible = isSelected, stop processing its children. The visibility of the parent controls the entire subtree.6.3 The "Sloppy Pixel" (Tolerance)Designers drag-and-drop. A hole might be positioned at x: 0.05 instead of 0.Challenge: Ray Casting might detect a vertex as "Outside" if it lies exactly on an edge or slightly off due to floating-point errors.Solution: Implement an Epsilon Tolerance ($\epsilon \approx 0.1px$) in all geometric checks. The standard Simulation of Simplicity approach in computational geometry suggests shifting test points slightly to avoid vertex collisions.6.4 Component Properties (The Golden Path)Figma introduced native Component Properties in 2022. Designers can explicitly link a layer's visibility to a boolean property named "Selected".Priority Rule: Before running any geometric inference, check node.componentPropertyReferences?.visible.If a reference exists (e.g., Selected=True), use this explicit intent immediately. It overrides all heuristic guesses. This is the most robust detection system available.7. Implementation Roadmap & RecommendationsTo permanently resolve the "Checkbox Refactoring Challenge," we recommend the following phased implementation plan for the engineering team.Phase 1: Data Structure EnhancementModify the parser to verify componentPropertyReferences first. If present, map strictly to these values. This covers well-structured design systems.Phase 2: The Geometric AnalyzerImplement the GeometricAnalyzer class.Input: A BooleanOperationNode.Process:Sort children by Z-index (Base = 0).For each child > 0:Run isAABBContained.If unclear, run isPointInPolygon (Ray Casting).Classify as HOLE, ICON, or UNKNOWN.Output: A Semantic Role Map ({ childId: 'HOLE' }).Phase 3: The Super-Template MergerUpdate ComponentRefactorer.ts to stop using items.Implement createSuperTemplate(items).Merge all item structures into a single JSON tree.Force visible: true on all nodes in the Super-Template for analysis.Phase 4: Logic Generation UpdateModify the code generator to respect the Role Map.TypeScript// Pseudocode for the new logic generation
const role = geometricAnalyzer.getRole(node);

if (role === 'HOLE') {
    // INVERTED BINDING
    code += `visible={!props.isSelected}`;
} else if (role === 'ICON') {
    // DIRECT BINDING
    code += `visible={props.isSelected}`;
} else {
    // FALLBACK / STATIC
    code += `visible={true}`; 
}
ConclusionThe "Solid Blob" is a symptom of a semantic translation error. By treating the Figma node tree not just as a list of visual layers, but as a structured geometric expression, we can infer the designer's intent. The "Hole" is a structural modifier that requires inverse logic. By implementing the Geometric Role Inference strategies detailed in this report—specifically Ray Casting and Variance Analysis—the ComponentRefactorer tool can achieve near-100% accuracy in translating static designs into dynamic, state-aware code, turning a persistent bug into a solved engineering problem.Table 1: Summary of Heuristics for Boolean Child NodesFeatureBase NodeHole NodeIcon/Content NodeOperation ParentAnySUBTRACT / EXCLUDEUNION / INTERSECT / NoneHierarchy PositionBottom (Index 0)Upper (Index 1+)Upper (Index 1+)Geometric RelationContainerContained (Inside Base)Overlapping / DisjointVisibility LogicConstant (True)Inverse (!State)Direct (State)Example ElementThe BoxThe Hollow CenterThe CheckmarkThis approach moves the tool from "Pattern Matching" to "Semantic Understanding," ensuring robustness against the variability inherent in human-generated design files.
