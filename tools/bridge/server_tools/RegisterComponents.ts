import * as fs from 'fs';
import * as path from 'path';

export function registerComponents() {
    console.log("üöÄ Running Component Registration Service...");

    const rootDir = process.cwd();
    const componentsDir = path.join(rootDir, 'components');
    const pagesDir = path.join(rootDir, 'pages');
    const slidesDir = path.join(rootDir, 'slides');
    const presentationsDir = path.join(rootDir, 'presentations');
    const indexFile = path.join(componentsDir, 'index.ts');

    console.log(`[DEBUG] CWD: ${process.cwd()}`);
    console.log(`[DEBUG] Slides Dir: ${slidesDir} (Exists: ${fs.existsSync(slidesDir)})`);

    if (!fs.existsSync(componentsDir)) {
        console.error("‚ùå Components directory not found!");
        return;
    }

    // Make file writable if it exists, to allow the new write
    if (fs.existsSync(indexFile)) {
        fs.chmodSync(indexFile, 0o666);
    }

    const exports: ComponentExport[] = [];
    const seenClasses = new Map<string, ComponentExport[]>();

    // Helpler to walk directory
    function walk(dir: string, project: string = "") {
        if (!fs.existsSync(dir)) return;
        const items = fs.readdirSync(dir);

        for (const item of items) {
            const fullPath = path.join(dir, item);
            const stat = fs.statSync(fullPath);

            if (stat.isDirectory()) {
                // Determine project name (first level folder under components)
                const newProject = project === "" ? item : project;
                console.log(`[DEBUG] Entering dir: ${item}, Project: ${newProject}`);
                walk(fullPath, newProject);
            } else if (item.endsWith('.ts')) {
                // Potential component file
                console.log(`[DEBUG] Found TS file: ${item}`);
                processFile(fullPath, project, exports, seenClasses);
            } else {
                console.log(`[DEBUG] Skipped item: ${item}`);
            }
        }
    }

    walk(componentsDir);
    walk(pagesDir);
    walk(slidesDir);
    walk(presentationsDir);

    // Generate content
    let content = "// This file is auto-generated by tools/RegisterComponents.ts\n";
    content += "// Do not edit this file manually.\n\n";

    // Sort to ensure deterministic output
    const sortedExports = resolveCollisions(seenClasses);

    for (const exp of sortedExports) {
        // Calculate relative path from components/index.ts
        let importPath = path.relative(componentsDir, exp.filePath);
        importPath = importPath.replace(/\.ts$/, '');
        if (!importPath.startsWith('.')) {
            importPath = './' + importPath;
        }

        if (exp.className.startsWith('Slide_')) {
            console.log(`[DEBUG] Adding Slide export: ${exp.className} from ${importPath}`);
        }

        if (exp.alias) {
            content += `export { ${exp.className} as ${exp.alias} } from "${importPath}";\n`;
        } else {
            content += `export { ${exp.className} } from "${importPath}";\n`;
        }
    }

    // Add Placeholder manually as it is in the root
    if (fs.existsSync(path.join(componentsDir, 'Placeholder.ts'))) {
        content += `export { Placeholder } from "./Placeholder";\n`;
    }

    if (fs.existsSync(indexFile)) {
        const existingContent = fs.readFileSync(indexFile, 'utf8').replace(/\r\n/g, '\n');
        const newContentNormalized = content.replace(/\r\n/g, '\n');

        if (existingContent === newContentNormalized) {
            console.log(`‚úÖ components/index.ts is up to date (skipped write).`);
            return;
        }
    }

    fs.writeFileSync(indexFile, content);

    // Make file writable (removed read-only flag as it caused EACCES errors in build tools)
    fs.chmodSync(indexFile, 0o644);

    const slideCount = (content.match(/Slide_/g) || []).length;
    console.log(`[DEBUG] Final content length: ${content.length}`);
    console.log(`[DEBUG] Slide exports found in content: ${slideCount}`);
    console.log(`[DEBUG] First 100 chars: ${content.substring(0, 100)}`);
    console.log(`[DEBUG] Last 100 chars: ${content.substring(content.length - 100)}`);

    console.log(`‚úÖ Registered ${sortedExports.length} components in components/index.ts`);
}

interface ComponentExport {
    className: string;
    filePath: string;
    project: string;
    alias?: string;
}

function processFile(filePath: string, project: string, exports: ComponentExport[], seenClasses: Map<string, ComponentExport[]>) {
    const content = fs.readFileSync(filePath, 'utf8');
    const fileName = path.basename(filePath);

    // Skip index.ts, BaseComponent.ts, and non-component files
    if (fileName === 'index.ts' || fileName === 'BaseComponent.ts' || fileName.includes('Helpers') || fileName === 'Placeholder.ts') return;

    // Simple regex to find exported class
    // export class ClassName ...
    // export class ClassName ...
    const classMatch = content.match(/export\s+class\s+([a-zA-Z0-9_]+)/);

    if (fileName === 'Slide_Title.ts') {
        console.log(`[DEBUG] processing Slide_Title.ts`);
        console.log(`[DEBUG] Content snippet: ${content.substring(0, 100)}...`);
        console.log(`[DEBUG] Match result: ${classMatch ? classMatch[1] : 'NULL'}`);
    }

    if (classMatch) {
        const className = classMatch[1];
        console.log(`[DEBUG] Found class ${className} in ${filePath}`);

        const exportData: ComponentExport = {
            className,
            filePath,
            project
        };

        if (!seenClasses.has(className)) {
            seenClasses.set(className, []);
        }
        seenClasses.get(className)!.push(exportData);
    }
}

function resolveCollisions(seenClasses: Map<string, ComponentExport[]>): ComponentExport[] {
    const finalExports: ComponentExport[] = [];

    for (const [className, matches] of seenClasses.entries()) {
        if (matches.length === 1) {
            // Unique
            console.log(`[DEBUG] resolveCollisions: adding unique class ${className}`);
            finalExports.push({ ...matches[0] });
        } else {
            console.log(`[DEBUG] resolveCollisions: resolving collision for ${className} (${matches.length} matches)`);
            for (const match of matches) {
                if (match.project) {
                    match.alias = `${className}_${match.project}`;
                } else {
                    match.alias = `${className}_Root`;
                }
                finalExports.push(match);
            }
        }
    }

    // Sort by final export name
    return finalExports.sort((a, b) => {
        const nameA = a.alias || a.className;
        const nameB = b.alias || b.className;
        return nameA.localeCompare(nameB);
    });
}

if (require.main === module) {
    registerComponents();
}
