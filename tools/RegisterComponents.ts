import * as fs from 'fs';
import * as path from 'path';

export function registerComponents() {
    console.log("üöÄ Running Component Registration Service...");

    const rootDir = process.cwd();
    const componentsDir = path.join(rootDir, 'components');
    const indexFile = path.join(componentsDir, 'index.ts');

    if (!fs.existsSync(componentsDir)) {
        console.error("‚ùå Components directory not found!");
        return;
    }

    const exports: ComponentExport[] = [];
    const seenClasses = new Map<string, ComponentExport[]>();

    // Helpler to walk directory
    function walk(dir: string, project: string = "") {
        const items = fs.readdirSync(dir);

        for (const item of items) {
            const fullPath = path.join(dir, item);
            const stat = fs.statSync(fullPath);

            if (stat.isDirectory()) {
                // Determine project name (first level folder under components)
                const newProject = project === "" ? item : project;
                walk(fullPath, newProject);
            } else if (item.endsWith('.ts')) {
                // Potential component file
                processFile(fullPath, project, exports, seenClasses);
            }
        }
    }

    walk(componentsDir);

    // Generate content
    let content = "// This file is auto-generated by tools/RegisterComponents.ts\n";
    content += "// Do not edit this file manually.\n\n";

    // Sort to ensure deterministic output
    const sortedExports = resolveCollisions(seenClasses);

    // Keep "Alex_CookBook" components for backward compatibility if possible,
    // or just follow the strict naming rule.
    // The previous index.ts had specific manual exports. We'll try to match that logic:
    // If a class name is unique -> export { ClassName }
    // If collision -> export { ClassName as ClassName_ProjectName }

    // Specifically for internal consistency, we used:
    // export { Component } from "./Project/Component/Component";

    // And for Alex_CookBook:
    // export { Component as Component_Alex_CookBook } from ...

    for (const exp of sortedExports) {
        // Calculate relative path from components/index.ts
        let importPath = path.relative(componentsDir, exp.filePath);
        importPath = importPath.replace(/\.ts$/, '');
        if (!importPath.startsWith('.')) {
            importPath = './' + importPath;
        }

        if (exp.alias) {
            content += `export { ${exp.className} as ${exp.alias} } from "${importPath}";\n`;
        } else {
            content += `export { ${exp.className} } from "${importPath}";\n`;
        }
    }

    // Add Placeholder manually as it is in the root
    if (fs.existsSync(path.join(componentsDir, 'Placeholder.ts'))) {
        content += `export { Placeholder } from "./Placeholder";\n`;
    }

    fs.writeFileSync(indexFile, content);
    console.log(`‚úÖ Registered ${sortedExports.length} components in components/index.ts`);
}

interface ComponentExport {
    className: string;
    filePath: string;
    project: string;
    alias?: string;
}

function processFile(filePath: string, project: string, exports: ComponentExport[], seenClasses: Map<string, ComponentExport[]>) {
    const content = fs.readFileSync(filePath, 'utf8');
    const fileName = path.basename(filePath);

    // Skip index.ts, BaseComponent.ts, and non-component files
    if (fileName === 'index.ts' || fileName === 'BaseComponent.ts' || fileName.includes('Helpers') || fileName === 'Placeholder.ts') return;

    // Simple regex to find exported class
    // export class ClassName ...
    const classMatch = content.match(/export\s+class\s+([a-zA-Z0-9_]+)/);

    if (classMatch) {
        const className = classMatch[1];

        // Also verify it extends BaseComponent or similar if we want to be strict, 
        // but for now, any exported class in components/ is fair game.

        const exportData: ComponentExport = {
            className,
            filePath,
            project
        };

        if (!seenClasses.has(className)) {
            seenClasses.set(className, []);
        }
        seenClasses.get(className)!.push(exportData);
    }
}

function resolveCollisions(seenClasses: Map<string, ComponentExport[]>): ComponentExport[] {
    const finalExports: ComponentExport[] = [];

    for (const [className, matches] of seenClasses.entries()) {
        if (matches.length === 1) {
            // Unique
            finalExports.push({ ...matches[0] });
        } else {
            // Collision - Collision Strategy
            // 1. If one of them is from "UEFA_Academy_online", it might be the "default" one based on user preference? 
            //    Or just alias ALL of them to prevent ambiguity.
            //    Existing logic seemed to alias Alex_CookBook.

            for (const match of matches) {
                // If the project is NOT empty, append it
                if (match.project) {
                    match.alias = `${className}_${match.project}`;
                } else {
                    // Root component? unlikely given the walker structure, but safely:
                    match.alias = `${className}_Root`;
                }
                finalExports.push(match);
            }
        }
    }

    // Sort by final export name
    return finalExports.sort((a, b) => {
        const nameA = a.alias || a.className;
        const nameB = b.alias || b.className;
        return nameA.localeCompare(nameB);
    });
}

if (require.main === module) {
    registerComponents();
}
